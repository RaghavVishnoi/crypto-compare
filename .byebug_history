c
JSON.parse(KrakenExchange.get_ohlc)
c
JSON.parse(KrakenExchange.get_ohlc)
c
@kraken_orderbook.body
@kraken_orderbook
c
quantities
c
bids_okcoin[0..10]c
quantities
c
@okcoin_bids_quantities
c
okcoin_orderbook.body
okcoin_orderbook
c
JSON.parse(okcoin_orderbook).deep_symbolize_keys[:bids]
c
first_buy > first_sell ? first_buy : first_sell
first_sell
first_buy
c
 first_price['buy']c
 first_price['buy'].split('-')
 first_price['buy'].split('-'))
 first_price['buy']
c
first_price
c
JSON.parse(@okcoin_orderbook.body)
@okcoin_orderbook.body
@okcoin_orderbook
c
asks_kraken[0..10].map{|order_book| order_book[1]}.sort
asks_kraken_prices[B
c
cc
c
"-"+(bids_kraken_prices[i])c
"-"+(bids_kraken_prices[i])
 -(bids_kraken_prices[i])
c
@krakens_details
c
asks_kraken.map{|order_book| order_book[1]}.sort[0..10]
asks_kraken.map{|order_book| order_book[1]}.sort.limit(10)
asks_kraken.map{|order_book| order_book[1]}.sort
bids_kraken.map{|order_book| order_book[1]}.sort
bids_kraken.map{|order_book| order_book[1]}
bids_kraken.each{|order_book| order_book[1]}
bids_kraken
c
asks_deribit_prices.sort
asks_deribit_prices.order
asks_deribit_prices.desc
asks_deribit_prices
bids_deribit_prices
c
trade.type
c
client.trades(pair)
client.trades(pair).last
pair
trade
trade.type
c
trade.type
c
trades.last.target
trades.last.price
trades.price
Time.at(trades.last.timestamp)
trades = client.trades(pair)
client.pairs(exchange_type).last
Time.at(trades.last.timestamp)
Time.at(trades.first.timestamp)
Time.at(trades.last.timestamp)
trades.last.timestamp
trades.last.at
trades.last
trades.type
trades = client.trades(pair)
client.trades(pair)
c
CryptoExchange.trade('kucoin')
CryptoExchange.trade('kucoin', 'okex')
CryptoExchange.trade('kucoin', 'okex)
c
CryptoExchange.trade('kucoin')
CryptoExchange.trades('kucoin')
c
@chart_data
c
@chart_data
c
Time.zone.now
Time.zone.parse(Time.at(JSON.parse(response.body).deep_symbolize_keys[:Data].first[:time]).to_s)
Time.zone = 'Central Time (US & Canada)'
Time.zone.parse(Time.at(JSON.parse(response.body).deep_symbolize_keys[:Data].first[:time]).to_s)
Time.zone.parse(Time.at(JSON.parse(response.body).deep_symbolize_keys[:Data].first[:time]))
Time.zone.iso8601(Time.at(JSON.parse(response.body).deep_symbolize_keys[:Data].first[:time]))
@chart_data = Time.at(JSON.parse(response.body).deep_symbolize_keys[:Data].first[:time]).est
@chart_data = Time.at(JSON.parse(response.body).deep_symbolize_keys[:Data].first[:time])
@chart_data = JSON.parse(response.body).deep_symbolize_keys[:Data].first[:time]
@chart_data = JSON.parse(response.body).deep_symbolize_keys[:Data].first
@chart_data = JSON.parse(response.body).deep_symbolize_keys[:Data]
@chart_data
c
@chart_data.count
@chart_datacount
c
@chart_data.unshift(['Time', 'Close'])
@chart_data
c
@chart_data
c
@chart_data.map{|chart_details| [Time.at(chart_details[:time]).strftime('%Y-%m-%d %H:%M'), chart_details[:close]]}
@chart_data.map{|chart_details| [Time.at(chart_details[:time]).strftime('%Y-%m-%d %HH:%MM'), chart_details[:close]]}
@chart_data.map{|chart_details| [Time.at(chart_details[:time]).strftime('%Y-%m-%d %HH:%MM), chart_details[:close]]}
@chart_data.map{|chart_details| [Time.at(chart_details[:time]), chart_details[:close]]}
@chart_data.map{|chart_details| [chart_details[:time], chart_details[:close]]}
@chart_data.map{|chart_details| chart_details[:time], chart_details[:close]}
@chart_data.first
@chart_data
c
JSON.parse(response.body)['Data']
JSON.parse(response.body)
response.body
response.code
response.status
response
c
@exchange_list[:Exchanges]
@exchange_list
c
@exchange_list
c
JSON.parse(response.body).deep_symbolize_keys[:Data]
exit
response
response.body
response.status
response
response.body
JSON.parse(response.body)
JSON.parse(response.body).deep_symbolize_keys
JSON.parse(response.body).deep_symbolize_keys[:Data]
@exchanges.body
@exchanges. body
@exchanges
@excganges
c
url
c
url
c
url
c
res = @news_details.map{|det| det if det[:id] == params[:id]}.compact.first
res = @news_details.map{|det| det if det[:id] == params[:id]}.compact
res = @news_details.map{|det| det if det[:id] == params[:id]}
res = @news_details.map{|det| det[:id]}
res = @news_details.each{|det| det[:id]}
params[:id]
res
res = @news_details.each{|det| det if det[:id] == params[:id]}
res
res = @news_details.each{|det| det[:id] == params[:id]}
@news_details.each{|det| det[:id] == params[:id]}
@news_details
c
@news_list.count
@news_list
c
@news_list.count
@news_list
c
JSON.parse(response.body)
JSON.parse(response.body)['Data'][0].deep_symbolize_keys
JSON.parse(response.body)['Data'][0].deep_symbolize_key
JSON.parse(response.body)['Data'][0].hash_with_indifferent_access
JSON.parse(response.body)['Data'][0]
JSON.parse(response.body)['Data'].hash_with_indifferent_access
JSON.parse(response.body)['Data']
JSON.parse(response.body)[:Data]
JSON.parse(response.body)
JSON.parse(response.body)[0]
JSON.parse(response.body).hash_with_indifferent_access
JSON.parse(response.body)
c
response.code
JSON.parse(response.body)
response.body
response
c
url
response
c
APP_CONSTANTS
APP_CONSTANTS['min-api']
APP_CONSTANTS['min-api']['base_url']
c
@page_no
c
Time.at(Cryptocompare::News.all[49]['published_on'])
Time.at(Cryptocompare::News.all[49])
Cryptocompare::News.all[49]
Cryptocompare::News.all
Time.at(Cryptocompare::News)
Time.at(Cryptocompare::News(50))
Time.at(Cryptocompare::News.last['published_on'])
Cryptocompare::News.all.count
Time.at(Cryptocompare::News.all.last['published_on'])
Time.at(Cryptocompare::News.all.first['published_on'])
Time.parse(Cryptocompare::News.all.first['published_on'].to_s)
DateTime.parse(Cryptocompare::News.all.first['published_on'].to_s)
DateTime.parse(Cryptocompare::News.all.first['published_on'])
Cryptocompare::News.all.first['published_on'].to_d
Cryptocompare::News.all.first['published_on'].to_date
Cryptocompare::News.all.first['published_on']
Cryptocompare::News.all.first
Cryptocompare::News.all
